# -*- coding: utf-8 -*-
"""mygames.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1th7UDzeDcWJRLF_m-C8jWbDFoPhiZcg2
"""

import pandas as pd
import numpy as np
import tensorflow as tf
from sklearn.preprocessing import MultiLabelBinarizer, StandardScaler
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Dense, Dropout, Concatenate
import re

def load_and_clean_data():
    my_games = pd.read_csv('mygames.csv')
    all_games = pd.read_csv('allgames.csv')

    my_games = my_games.dropna(subset=['Title', 'Genres'])
    my_games['Rating'] = pd.to_numeric(my_games['Rating'], errors='coerce')
    all_games['Rating'] = all_games['Rating'].str.split('/').str[0].astype(float)

    all_games['Rating'] = all_games['Rating'] / 2
    my_games['Release Year'] = pd.to_numeric(my_games['Release Year'], errors='coerce')
    all_games['Release Year'] = pd.to_numeric(all_games['Release Year'], errors='coerce')

    my_games['Genres'] = my_games['Genres'].str.split('/')
    all_games['Genres'] = all_games['Genres'].str.split('/')
    all_games['In Collection'] = all_games['Title'].isin(my_games['Title'])

    return my_games, all_games

def extract_features(my_games, all_games):
    all_genres = set()
    for genres in my_games['Genres'].dropna():
        all_genres.update([g.strip() for g in genres])
    for genres in all_games['Genres'].dropna():
        all_genres.update([g.strip() for g in genres])

    mlb = MultiLabelBinarizer(classes=list(all_genres))

    my_games_genres = pd.DataFrame(
        mlb.fit_transform(my_games['Genres'].fillna('').apply(lambda x: [g.strip() for g in x] if isinstance(x, list) else [])),
        columns=mlb.classes_
    )
    all_games_genres = pd.DataFrame(
        mlb.transform(all_games['Genres'].fillna('').apply(lambda x: [g.strip() for g in x] if isinstance(x, list) else [])),
        columns=mlb.classes_
    )

    current_year = 2025
    my_games_years = (current_year - my_games['Release Year'].fillna(2010)) / 50
    all_games_years = (current_year - all_games['Release Year'].fillna(2010)) / 50
    my_games_features = pd.concat([my_games_genres, my_games_years.rename('Year')], axis=1)
    all_games_features = pd.concat([all_games_genres, all_games_years.rename('Year')], axis=1)

    return my_games_features, all_games_features, list(mlb.classes_)

def create_rating_training_data(my_games, my_games_features):
    rated_games = my_games.dropna(subset=['Rating'])
    rated_features = my_games_features.iloc[rated_games.index]
    ratings = rated_games['Rating'].values
    ratings = ratings / 5.0
    return rated_features.values, ratings

def build_recommendation_model(input_dim):
    game_input = Input(shape=(input_dim,), name='game_features')

    x = Dense(128, activation='relu')(game_input)
    x = Dropout(0.3)(x)
    x = Dense(64, activation='relu')(x)
    x = Dropout(0.3)(x)
    x = Dense(32, activation='relu')(x)
    output = Dense(1, activation='sigmoid', name='rating')(x)

    model = Model(inputs=game_input, outputs=output)
    model.compile(
        optimizer=tf.keras.optimizers.Adam(0.001),
        loss='mean_squared_error',
        metrics=['mae']
    )

    return model

def train_model(X, y):
    X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42)
    model = build_recommendation_model(X_train.shape[1])
    history = model.fit(
        X_train, y_train,
        validation_data=(X_val, y_val),
        epochs=100,
        batch_size=8,
        verbose=0,
        callbacks=[
            tf.keras.callbacks.EarlyStopping(
                monitor='val_loss',
                patience=10,
                restore_best_weights=True
            )
        ]
    )

    return model

def get_recommendations(model, all_games, my_games_features, all_games_features, my_games, genre_cols, top_n=10):
    predicted_ratings = model.predict(all_games_features.values)
    recommendations = pd.DataFrame({
        'Title': all_games['Title'],
        'Release Year': all_games['Release Year'],
        'Genres': all_games['Genres'].apply(lambda x: '/'.join(x) if isinstance(x, list) else x),
        'Developer': all_games['Developer'],
        'Publisher': all_games['Publisher'],
        'Price': all_games['Price'],
        'Rating': all_games['Rating'] * 2,
        'Predicted Rating': predicted_ratings.flatten() * 5,
        'In Collection': all_games['In Collection']
    })

    new_games = recommendations[~recommendations['In Collection']]

    recommended_games = new_games.sort_values('Predicted Rating', ascending=False).head(top_n)

    my_games_genre_profile = my_games_features[genre_cols].mean(axis=0)

    def generate_explanation(row):
        game_genres = all_games_features.iloc[row.name][genre_cols]
        similar_genres = [genre for genre, has_genre in zip(genre_cols, game_genres) if has_genre > 0]
        preferred_genres = [genre for genre, score in zip(genre_cols, my_games_genre_profile) if score > 0.1]
        common_genres = set(similar_genres).intersection(set(preferred_genres))
        if common_genres:
            return f"Recommended because you enjoy {', '.join(list(common_genres)[:3])} games"
        else:
            return "Recommended to diversify your collection"

    recommended_games['Explanation'] = recommended_games.apply(generate_explanation, axis=1)

    return recommended_games[['Title', 'Release Year', 'Genres', 'Developer', 'Publisher', 'Price',
                             'Rating', 'Predicted Rating', 'Explanation']]

if __name__ == "__main__":
  my_games, all_games = load_and_clean_data()
  my_games_features, all_games_features, genre_cols = extract_features(my_games, all_games)
  X, y = create_rating_training_data(my_games, my_games_features)

  model = train_model(X, y)

  recommendations = get_recommendations(model, all_games, my_games_features, all_games_features, my_games, genre_cols)
  if len(my_games) > 0:
      top_rated = my_games.sort_values('Rating', ascending=False).head(3)
      favorite_genres = []
      for genres in top_rated['Genres']:
          if isinstance(genres, list):
              favorite_genres.extend(genres)
          most_common_genre = max(set(favorite_genres), key=favorite_genres.count)
      print(f"Since you enjoy {most_common_genre} games, you might like:")
      genre_recs = recommendations[recommendations['Genres'].str.contains(most_common_genre, na=False)].head(3)
      pd.set_option('display.max_columns', None)
      pd.set_option('display.width', 1000)
      print(recommendations.to_string(index=False))
      if not genre_recs.empty:
          print(genre_recs[['Title', 'Release Year', 'Genres', 'Predicted Rating']].to_string(index=False))